<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seenuri Works â€” Advanced WebGL</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600&display=swap" rel="stylesheet">

    <style>
        :root {
            --bg: #050505;
            --text: #ffffff;
            --accent: #FF3B30;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background-color: var(--bg);
            font-family: 'Space Grotesk', sans-serif;
            overflow-x: hidden;
            color: var(--text);
            overscroll-behavior: none;
        }

        /* CANVASES */
        #canvas-container {
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: -1;
            pointer-events: none;
        }

        /* DOM CONTENT (This acts as a "Skeleton" for the WebGL) */
        main {
            position: relative;
            z-index: 10;
        }

        header {
            position: fixed;
            top: 0; left: 0; width: 100%;
            padding: 40px;
            display: flex;
            justify-content: space-between;
            mix-blend-mode: difference;
            z-index: 100;
        }

        .logo { font-size: 24px; font-weight: 700; text-transform: uppercase; letter-spacing: 2px; }
        .menu { font-size: 14px; text-transform: uppercase; letter-spacing: 1px; cursor: pointer; }

        .section {
            padding: 10vh 10vw;
            position: relative;
        }

        .hero {
            height: 100vh;
            display: flex;
            align-items: center;
        }

        h1 {
            font-size: 10vw;
            line-height: 0.85;
            text-transform: uppercase;
            mix-blend-mode: difference;
        }

        /* THE IMAGE PLACEHOLDERS 
           (These are invisible but tell WebGL where to render) */
        .image-wrapper {
            width: 100%;
            max-width: 600px;
            height: 80vh;
            margin: 10vh 0;
            opacity: 0; /* Crucial: We hide DOM, show WebGL */
            visibility: hidden;
        }

        .grid-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10vw;
            padding-bottom: 20vh;
        }

        .project-info {
            padding-top: 10vh;
        }

        .project-title { font-size: 4vw; margin-bottom: 20px; }
        .project-meta { font-size: 14px; opacity: 0.6; text-transform: uppercase; letter-spacing: 1px; }

        /* SCROLLBAR HIDE */
        ::-webkit-scrollbar { display: none; }
    </style>
</head>
<body>

    <div id="canvas-container"></div>

    <header>
        <div class="logo">Seenuri.</div>
        <div class="menu">Menu</div>
    </header>

    <main id="scroll-container">
        <section class="section hero">
            <h1>Digital<br>Reality<br>System</h1>
        </section>

        <section class="section grid-section">
            <div class="project-info">
                <div class="project-meta">01 / Zapwash</div>
                <h2 class="project-title">Hyperlocal<br>Commerce</h2>
                <p>Advanced Shopify Architecture</p>
            </div>
            <img class="image-wrapper" src="https://images.unsplash.com/photo-1605218427335-3a4dd9840f1c?q=80&w=1500&auto=format&fit=crop" data-webgl="true" alt="Zapwash">
        </section>

        <section class="section grid-section" style="direction: rtl;">
            <div class="project-info" style="direction: ltr;">
                <div class="project-meta">02 / Chinkulu</div>
                <h2 class="project-title">Cultural<br>Heritage</h2>
                <p>Brand Identity System</p>
            </div>
            <img class="image-wrapper" src="https://images.unsplash.com/photo-1558769132-cb1aea458c5e?q=80&w=1500&auto=format&fit=crop" data-webgl="true" alt="Chinkulu">
        </section>

        <section class="section grid-section">
            <div class="project-info">
                <div class="project-meta">03 / Vinthapadalu</div>
                <h2 class="project-title">Literature<br>Revival</h2>
                <p>Community Platform</p>
            </div>
            <img class="image-wrapper" src="https://images.unsplash.com/photo-1544716278-ca5e3f4abd8c?q=80&w=1500&auto=format&fit=crop" data-webgl="true" alt="Vinthapadalu">
        </section>

        <section class="section hero">
            <h1>Next<br>Project?</h1>
        </section>
    </main>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/studio-freight/lenis@1.0.29/bundled/lenis.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        /**
         * SHADER DEFINITIONS
         * This is raw GLSL code running on the Graphics Card.
         * This creates the "Liquid" effect.
         */
        const vertexShader = `
            uniform float uTime;
            uniform vec2 uHover;
            uniform float uHoverState;
            varying vec2 vUv;

            void main() {
                vUv = uv;
                vec3 newPos = position;

                // DISTORTION LOGIC
                float dist = distance(uv, uHover);
                
                // Create a wave effect based on mouse distance
                float wave = sin(dist * 10.0 - uTime * 2.0) * 0.1;
                
                // Apply distortion only when hovering
                newPos.z += wave * uHoverState * 0.5;

                gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);
            }
        `;

        const fragmentShader = `
            uniform sampler2D uTexture;
            uniform vec2 uImageSize;
            uniform vec2 uPlaneSize;
            uniform float uHoverState;
            varying vec2 vUv;

            // COVER FUNCTION (Mimics CSS background-size: cover)
            vec2 getCoverUv(vec2 uv, vec2 planeSize, vec2 imageSize) {
                vec2 ratio = vec2(
                    min((planeSize.x / planeSize.y) / (imageSize.x / imageSize.y), 1.0),
                    min((planeSize.y / planeSize.x) / (imageSize.y / imageSize.x), 1.0)
                );
                vec2 newUv = vec2(
                    uv.x * ratio.x + (1.0 - ratio.x) * 0.5,
                    uv.y * ratio.y + (1.0 - ratio.y) * 0.5
                );
                return newUv;
            }

            void main() {
                vec2 uv = getCoverUv(vUv, uPlaneSize, uImageSize);

                // RGB SHIFT EFFECT (Chromatic Aberration)
                float shift = uHoverState * 0.02;
                float r = texture2D(uTexture, uv + vec2(shift, 0.0)).r;
                float g = texture2D(uTexture, uv).g;
                float b = texture2D(uTexture, uv - vec2(shift, 0.0)).b;

                gl_FragColor = vec4(r, g, b, 1.0);
            }
        `;

        /**
         * CLASS: WEBGL MANAGER
         * Handles the Three.js Scene, Camera, and Renderer
         */
        class WebGL {
            constructor() {
                this.scene = new THREE.Scene();
                
                this.width = window.innerWidth;
                this.height = window.innerHeight;

                this.container = document.getElementById('canvas-container');

                this.renderer = new THREE.WebGLRenderer({
                    alpha: true,
                    antialias: true
                });
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.setSize(this.width, this.height);
                this.container.appendChild(this.renderer.domElement);

                // PERSPECTIVE CAMERA SETUP
                // We calculate FOV to match CSS pixels exactly
                this.camera = new THREE.PerspectiveCamera(70, this.width / this.height, 100, 2000);
                this.camera.position.z = 600; 
                this.camera.fov = 2 * Math.atan((this.height / 2) / 600) * (180 / Math.PI);

                this.images = [];
                this.currentScroll = 0;
                
                // MOUSE TRACKING
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();

                this.setupResize();
                this.addObjects();
                this.setupMouseEvents();
                this.render();
            }

            setupResize() {
                window.addEventListener('resize', () => {
                    this.width = window.innerWidth;
                    this.height = window.innerHeight;
                    this.renderer.setSize(this.width, this.height);
                    this.camera.aspect = this.width / this.height;
                    
                    // Recalculate FOV to keep objects sized correctly
                    this.camera.fov = 2 * Math.atan((this.height / 2) / 600) * (180 / Math.PI);
                    this.camera.updateProjectionMatrix();

                    // Update all image planes
                    this.images.forEach(img => img.updateBounds());
                });
            }

            setupMouseEvents() {
                window.addEventListener('mousemove', (e) => {
                    // Normalized coordinates for Raycaster
                    this.mouse.x = (e.clientX / this.width) * 2 - 1;
                    this.mouse.y = -(e.clientY / this.height) * 2 + 1;

                    // Raycasting logic
                    this.raycaster.setFromCamera(this.mouse, this.camera);
                    const intersects = this.raycaster.intersectObjects(this.scene.children);

                    if(intersects.length > 0) {
                        let obj = intersects[0].object;
                        obj.material.uniforms.uHover.value = intersects[0].uv;
                    }
                });
            }

            addObjects() {
                // Find all images with data-webgl="true"
                const elements = [...document.querySelectorAll('[data-webgl]')];
                
                elements.forEach(el => {
                    const img = new ImageObject({
                        element: el,
                        scene: this.scene,
                        geometry: new THREE.PlaneBufferGeometry(1, 1, 32, 32) // High segment count for smooth wave distortion
                    });
                    this.images.push(img);
                });
            }

            updateScroll(scrollY) {
                this.currentScroll = scrollY;
                this.images.forEach(img => {
                    img.update(scrollY, this.raycaster, this.mouse);
                });
            }

            render() {
                this.renderer.render(this.scene, this.camera);
                requestAnimationFrame(this.render.bind(this));
            }
        }

        /**
         * CLASS: IMAGE OBJECT
         * Represents a single image in the 3D world
         */
        class ImageObject {
            constructor({ element, scene, geometry }) {
                this.element = element;
                this.scene = scene;
                this.geometry = geometry;
                
                this.offset = new THREE.Vector2(0, 0); 
                this.sizes = new THREE.Vector2(0, 0);

                this.createMesh();
            }

            createMesh() {
                const src = this.element.src;
                
                // Load Texture
                const texture = new THREE.TextureLoader().load(src);
                texture.minFilter = THREE.LinearFilter;
                
                // Create Shader Material
                this.material = new THREE.ShaderMaterial({
                    uniforms: {
                        uTexture: { value: texture },
                        uImageSize: { value: new THREE.Vector2(0, 0) }, // Will be set on load
                        uPlaneSize: { value: new THREE.Vector2(0, 0) },
                        uHover: { value: new THREE.Vector2(0.5, 0.5) },
                        uHoverState: { value: 0 },
                        uTime: { value: 0 }
                    },
                    vertexShader: vertexShader,
                    fragmentShader: fragmentShader,
                    side: THREE.DoubleSide
                });

                this.mesh = new THREE.Mesh(this.geometry, this.material);
                this.scene.add(this.mesh);

                // Get natural image dimensions
                const img = new Image();
                img.src = src;
                img.onload = () => {
                    this.material.uniforms.uImageSize.value.set(img.naturalWidth, img.naturalHeight);
                    this.updateBounds();
                };
            }

            updateBounds() {
                // Determine where the HTML element is on screen
                const bounds = this.element.getBoundingClientRect();
                
                this.sizes.set(bounds.width, bounds.height);
                this.material.uniforms.uPlaneSize.value = this.sizes;

                this.mesh.scale.set(this.sizes.x, this.sizes.y, 1);

                // Calculate position relative to center of screen (WebGL coordinates)
                this.offset.x = bounds.left - window.innerWidth / 2 + bounds.width / 2;
                this.offset.y = -bounds.top + window.innerHeight / 2 - bounds.height / 2;
                
                // Store initial Y for scroll calculations
                this.y = this.offset.y; 
                this.x = this.offset.x;

                this.mesh.position.set(this.x, this.y, 0);
            }

            update(scrollY, raycaster, mouse) {
                // Update Position based on Scroll
                // We add scrollY because in WebGL Y goes up, in DOM Y goes down
                this.mesh.position.y = this.y + scrollY;

                // Update Time Uniform
                this.material.uniforms.uTime.value += 0.05;

                // Check for Hover Intersections (Manual raycast check per object for state)
                const intersects = raycaster.intersectObject(this.mesh);
                if (intersects.length > 0) {
                    // Smoothly transition hover state to 1
                    gsap.to(this.material.uniforms.uHoverState, {
                        value: 1,
                        duration: 0.5,
                        ease: "power2.out"
                    });
                } else {
                    // Smoothly transition hover state to 0
                    gsap.to(this.material.uniforms.uHoverState, {
                        value: 0,
                        duration: 0.5,
                        ease: "power2.out"
                    });
                }
            }
        }

        /**
         * INITIALIZATION
         * Combining Smooth Scroll (Lenis) with WebGL
         */
        
        // 1. Initialize Lenis Smooth Scroll
        const lenis = new Lenis({
            duration: 1.2,
            easing: (t) => Math.min(1, 1.001 - Math.pow(2, -10 * t)),
            smooth: true
        });

        // 2. Initialize WebGL World
        const webgl = new WebGL();

        // 3. Animation Loop
        function raf(time) {
            lenis.raf(time);
            
            // Sync WebGL with Scroll
            webgl.updateScroll(lenis.scroll);
            
            requestAnimationFrame(raf);
        }

        requestAnimationFrame(raf);

        // 4. Initial Trigger to set positions
        setTimeout(() => {
            webgl.images.forEach(img => img.updateBounds());
        }, 100);

    </script>
</body>
</html>
